package main

import (
	"bufio"
	"fmt"
	"os"
	"encoding/base64"
	"encoding/hex"
	"strings"
	"crypto/aes"
	"crypto/cipher"
)

func scanf(fname *string) ([]string, error) {
	retslice := make([]string, 0)
	f, err := os.Open(*fname)
	if err != nil {
		fmt.Fprintf(os.Stderr, "[-] %s\n", err)
		os.Exit(-1)
	}
	defer func() ([]string, error) {
		return retslice, (*f).Close()
	}()

	var scanner *bufio.Scanner = nil
	for scanner = bufio.NewScanner(f); scanner.Scan(); {
		splits := strings.Split(scanner.Text(), ":")
		var s string
		if strings.Contains(splits[0], "KEY") {
			sbytes, err := base64.StdEncoding.DecodeString(splits[1])
			if err != nil {
				return retslice, err
			}
			if splits[0] == "KEY000" {
				s = string(sbytes[:])
			} else {
				var stmp string
				stmp, retslice = retslice[len(retslice)-1], retslice[:len(retslice)-1]
				s = stmp + string(sbytes[:])
			}
		} else {
			s = splits[1]
		}

		retslice = append(retslice, s)
	}
	return retslice, scanner.Err()
}

func decode_msg(retslice []string) (string, error){
	var final_msg string
	iv, err := hex.DecodeString(retslice[0])
	if err != nil {
		return final_msg, err
	}
	key := []byte(retslice[1])
	block, err := aes.NewCipher(key)
	if err != nil {
		return final_msg, err
	}

	ciphertext := []byte(retslice[2])
	mode := cipher.NewCBCDecrypter(block, iv)
	mode.CryptBlocks(ciphertext, ciphertext)
	final_msg = string(ciphertext)
	return final_msg, nil
}

func main() {
	if len(os.Args) != 2 {
		fmt.Fprintf(os.Stderr, "[!]Usage ./decrypt <key_file>\n")
		os.Exit(-1)
	}

	retslice, err := scanf(&os.Args[1])
	if err != nil {
		fmt.Fprintf(os.Stderr, "[-] %s\n", err)
		os.Exit(-1)
	}

	final_msg, err := decode_msg(retslice)
	if err != nil {
		fmt.Fprintf(os.Stderr, "[-] %s\n", err)
		os.Exit(-1)
	}

	fmt.Printf("%s\n", final_msg)
}
